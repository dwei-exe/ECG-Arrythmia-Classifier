function convert_noisy_ecg_to_scalograms()
    % Convert noisy ECG signals to scalogram images using Continuous Wavelet Transform
    % FOCUS: Processes noisy Lead II signals (4 seconds) generated by noise addition system
    % Uses analytic Morlet wavelet with 12 voices per octave
    % Output: 227x227 RGB images with jet colormap
    
    % Define paths
    noisy_dataset_path = 'C:\Users\henry\Downloads\ECG-Dx\Noisy_ECG_Dataset';
    scalogram_output_path = 'C:\Users\henry\Downloads\ECG-Dx\Noisy_Scalogram_Dataset';
    
    % Create output directory
    if ~exist(scalogram_output_path, 'dir')
        mkdir(scalogram_output_path);
    end
    
    % ECG parameters
    fs = 500; % Sampling frequency (Hz)
    target_size = [227, 227]; % Target image size
    voices_per_octave = 12; % Number of voices per octave
    duration_seconds = 4; % 4 seconds of data
    target_samples = fs * duration_seconds; % 2000 samples
    
    % Initialize counters
    total_processed = 0;
    total_converted = 0;
    conversion_errors = 0;
    
    fprintf('=== NOISY ECG TO SCALOGRAM CONVERSION ===\n');
    fprintf('Noisy dataset path: %s\n', noisy_dataset_path);
    fprintf('Scalogram output path: %s\n', scalogram_output_path);
    fprintf('Target image size: %dx%d pixels\n', target_size(1), target_size(2));
    fprintf('Processing: Noisy Lead II (4 seconds = %d samples)\n', target_samples);
    fprintf('Wavelet: Analytic Morlet (amor)\n');
    fprintf('Voices per octave: %d\n', voices_per_octave);
    fprintf('Colormap: Jet (128 colors)\n\n');
    
    % Find all SNR directories
    snr_dirs = dir(fullfile(noisy_dataset_path, 'SNR_*'));
    snr_dirs = snr_dirs([snr_dirs.isdir]);
    
    if isempty(snr_dirs)
        error('No SNR directories found in %s', noisy_dataset_path);
    end
    
    fprintf('Found %d SNR levels to process\n', length(snr_dirs));
    
    % Process each SNR level
    for snr_idx = 1:length(snr_dirs)
        snr_name = snr_dirs(snr_idx).name;
        fprintf('\nProcessing %s...\n', snr_name);
        
        snr_path = fullfile(noisy_dataset_path, snr_name);
        
        % Find all noise type directories
        noise_dirs = dir(snr_path);
        noise_dirs = noise_dirs([noise_dirs.isdir] & ~strcmp({noise_dirs.name}, '.') & ~strcmp({noise_dirs.name}, '..'));
        
        for noise_idx = 1:length(noise_dirs)
            noise_type = noise_dirs(noise_idx).name;
            fprintf('  Processing noise type: %s\n', noise_type);
            
            noise_path = fullfile(snr_path, noise_type);
            
            % Process training and validation datasets
            datasets = {'training', 'validation'};
            groups = {'AFIB', 'SB', 'SR'};
            
            for dataset_idx = 1:length(datasets)
                dataset_name = datasets{dataset_idx};
                
                for group_idx = 1:length(groups)
                    group_name = groups{group_idx};
                    
                    % Define input and output directories
                    input_dir = fullfile(noise_path, dataset_name, group_name);
                    output_dir = fullfile(scalogram_output_path, snr_name, noise_type, dataset_name, group_name);
                    
                    if ~exist(input_dir, 'dir')
                        continue; % Skip if directory doesn't exist
                    end
                    
                    % Create output directory
                    if ~exist(output_dir, 'dir')
                        mkdir(output_dir);
                    end
                    
                    % Get all .mat files
                    mat_files = dir(fullfile(input_dir, '*.mat'));
                    
                    if isempty(mat_files)
                        continue;
                    end
                    
                    fprintf('    Processing %s/%s: %d files\n', dataset_name, group_name, length(mat_files));
                    
                    % Process each noisy ECG file
                    for file_idx = 1:length(mat_files)
                        total_processed = total_processed + 1;
                        
                        mat_file_path = fullfile(input_dir, mat_files(file_idx).name);
                        [~, base_name, ~] = fileparts(mat_files(file_idx).name);
                        
                        try
                            % Load noisy ECG data
                            ecg_data = load(mat_file_path);
                            
                            % Extract signal (should be stored as 'val')
                            if isfield(ecg_data, 'val')
                                noisy_signal = ecg_data.val;
                            else
                                fprintf('      Warning: No "val" field in %s\n', mat_files(file_idx).name);
                                conversion_errors = conversion_errors + 1;
                                continue;
                            end
                            
                            % Ensure signal is the right length
                            if length(noisy_signal) ~= target_samples
                                fprintf('      Warning: Signal length mismatch in %s (%d vs %d)\n', ...
                                        mat_files(file_idx).name, length(noisy_signal), target_samples);
                                conversion_errors = conversion_errors + 1;
                                continue;
                            end
                            
                            % Generate scalogram for noisy Lead II
                            scalogram_img = generate_noisy_scalogram(noisy_signal, fs, voices_per_octave, target_size);
                            
                            % Create output filename preserving noise information
                            % Format: [PATIENT_ID]_age[AGE]_NOISE_[noise_type]_SNR[XX]_Lead2_4sec.png
                            output_filename = sprintf('%s_Lead2_4sec.png', base_name);
                            output_filepath = fullfile(output_dir, output_filename);
                            
                            % Save scalogram image
                            imwrite(scalogram_img, output_filepath);
                            
                            total_converted = total_converted + 1;
                            
                            % Progress update
                            if mod(total_processed, 100) == 0
                                fprintf('      Processed %d files, converted %d...\n', total_processed, total_converted);
                            end
                            
                        catch ME
                            fprintf('      Error processing %s: %s\n', mat_files(file_idx).name, ME.message);
                            conversion_errors = conversion_errors + 1;
                            continue;
                        end
                    end
                end
            end
        end
        
        fprintf('  Completed %s\n', snr_name);
    end
    
    % Final summary
    fprintf('\n=== NOISY SCALOGRAM CONVERSION SUMMARY ===\n');
    fprintf('Total noisy files processed: %d\n', total_processed);
    fprintf('Successfully converted: %d\n', total_converted);
    fprintf('Conversion errors: %d\n', conversion_errors);
    if total_processed > 0
        fprintf('Success rate: %.1f%%\n', (total_converted/total_processed)*100);
    end
    fprintf('Scalogram output directory: %s\n', scalogram_output_path);
    
    % Generate conversion report
    generate_noisy_conversion_report(scalogram_output_path, total_processed, total_converted, conversion_errors);
    
    % Generate noisy scalogram analysis
    analyze_noisy_scalogram_dataset(scalogram_output_path);
    
    fprintf('\nNoisy scalogram dataset ready for model testing!\n');
end

function scalogram_img = generate_noisy_scalogram(signal, fs, voices_per_octave, target_size)
    % Generate scalogram for noisy Lead II using Continuous Wavelet Transform
    
    % Preprocess signal
    signal = double(signal);
    signal = signal - mean(signal); % Remove DC component
    
    % Robust normalization (important for noisy signals)
    signal_std = std(signal);
    if signal_std > eps
        signal = signal / signal_std;  % Normalize
    else
        signal = signal; % Keep as is if std is too small
    end
    
    % Apply CWT with analytic Morlet wavelet
    try
        [wt, frequencies] = cwt(signal, 'amor', fs, 'VoicesPerOctave', voices_per_octave);
    catch
        % Fallback for older MATLAB versions
        [wt, frequencies] = cwt(signal, 'amor', fs);
    end
    
    % Convert to scalogram (magnitude)
    scalogram = abs(wt);
    
    % Apply logarithmic scaling for better visualization
    scalogram = log10(scalogram + eps);
    
    % Robust normalization to [0, 1] range (crucial for noisy data)
    scalogram_min = min(scalogram(:));
    scalogram_max = max(scalogram(:));
    if scalogram_max > scalogram_min
        scalogram = (scalogram - scalogram_min) / (scalogram_max - scalogram_min);
    else
        scalogram = zeros(size(scalogram)); % Handle constant signal case
    end
    
    % Apply jet colormap with 128 colors
    jet_colormap = jet(128);
    
    % Convert scalogram to RGB image
    scalogram_indexed = round(scalogram * 127) + 1; % Map to 1-128 range
    scalogram_indexed = max(1, min(128, scalogram_indexed)); % Clamp values
    scalogram_rgb = ind2rgb(scalogram_indexed, jet_colormap);
    
    % Resize to target dimensions using bicubic interpolation
    scalogram_img = imresize(scalogram_rgb, target_size, 'bicubic');
    
    % Convert to uint8 for image saving
    scalogram_img = uint8(scalogram_img * 255);
end

function generate_noisy_conversion_report(scalogram_output_path, total_processed, total_converted, conversion_errors)
    % Generate comprehensive conversion report for noisy scalograms
    
    report_file = fullfile(scalogram_output_path, 'noisy_scalogram_conversion_report.txt');
    fid = fopen(report_file, 'w');
    
    fprintf(fid, '=== NOISY ECG TO SCALOGRAM CONVERSION REPORT ===\n');
    fprintf(fid, 'Date: %s\n\n', datestr(now));
    
    fprintf(fid, 'CONVERSION PARAMETERS:\n');
    fprintf(fid, '- Source: Noisy ECG Lead II signals\n');
    fprintf(fid, '- Duration: 4 seconds (2000 samples @ 500 Hz)\n');
    fprintf(fid, '- Wavelet: Analytic Morlet (amor)\n');
    fprintf(fid, '- Voices per octave: 12\n');
    fprintf(fid, '- Target image size: 227x227 pixels\n');
    fprintf(fid, '- Color format: RGB\n');
    fprintf(fid, '- Colormap: Jet (128 colors)\n');
    fprintf(fid, '- Interpolation: Bicubic\n\n');
    
    fprintf(fid, 'NOISE CONDITIONS:\n');
    fprintf(fid, '- Noise types: gaussian, powerline, baseline_wander, muscle_artifact,\n');
    fprintf(fid, '               motion_artifact, electrode_noise, combined\n');
    fprintf(fid, '- SNR levels: 30, 20, 15, 10, 5, 0 dB\n');
    fprintf(fid, '- Total combinations: 7 noise types × 6 SNR levels = 42 per original file\n\n');
    
    fprintf(fid, 'CONVERSION STATISTICS:\n');
    fprintf(fid, 'Total noisy files processed: %d\n', total_processed);
    fprintf(fid, 'Successfully converted: %d\n', total_converted);
    fprintf(fid, 'Conversion errors: %d\n', conversion_errors);
    
    if total_processed > 0
        success_rate = (total_converted / total_processed) * 100;
        fprintf(fid, 'Success rate: %.1f%%\n', success_rate);
    end
    
    fprintf(fid, '\nOUTPUT STRUCTURE:\n');
    fprintf(fid, 'Directory structure:\n');
    fprintf(fid, 'SNR_XXdB/[noise_type]/[training|validation]/[AFIB|SB|SR]/\n');
    fprintf(fid, '\nFilename format:\n');
    fprintf(fid, '[PATIENT_ID]_age[AGE]_NOISE_[noise_type]_SNR[XX]_Lead2_4sec.png\n');
    
    fprintf(fid, '\nEXAMPLE FILENAMES:\n');
    fprintf(fid, '- JS44163_age45_NOISE_gaussian_SNR10_Lead2_4sec.png\n');
    fprintf(fid, '- TR09173_age67_NOISE_combined_SNR05_Lead2_4sec.png\n');
    
    fprintf(fid, '\nRESEARCH APPLICATIONS:\n');
    fprintf(fid, '- Model robustness testing under noise conditions\n');
    fprintf(fid, '- Performance evaluation across different SNR levels\n');
    fprintf(fid, '- Noise type sensitivity analysis\n');
    fprintf(fid, '- Real-world deployment readiness assessment\n');
    
    if conversion_errors > 0
        fprintf(fid, '\nERROR ANALYSIS:\n');
        fprintf(fid, 'Common error causes:\n');
        fprintf(fid, '- Missing "val" field in noisy signal files\n');
        fprintf(fid, '- Signal length mismatches\n');
        fprintf(fid, '- Corrupted noise data files\n');
        fprintf(fid, '- Insufficient memory for large datasets\n');
    else
        fprintf(fid, '\nNo conversion errors encountered.\n');
    end
    
    fclose(fid);
    
    fprintf('Conversion report saved to: %s\n', report_file);
end

function analyze_noisy_scalogram_dataset(scalogram_output_path)
    % Analyze the generated noisy scalogram dataset
    
    fprintf('\n=== NOISY SCALOGRAM DATASET ANALYSIS ===\n');
    
    % Find all SNR directories
    snr_dirs = dir(fullfile(scalogram_output_path, 'SNR_*'));
    snr_dirs = snr_dirs([snr_dirs.isdir]);
    
    if isempty(snr_dirs)
        fprintf('No SNR directories found for analysis.\n');
        return;
    end
    
    datasets = {'training', 'validation'};
    groups = {'AFIB', 'SB', 'SR'};
    
    total_scalograms = 0;
    analysis_summary = struct();
    
    fprintf('SNR Level Analysis:\n');
    
    for snr_idx = 1:length(snr_dirs)
        snr_name = snr_dirs(snr_idx).name;
        fprintf('\n%s:\n', snr_name);
        
        snr_path = fullfile(scalogram_output_path, snr_name);
        
        % Find noise type directories
        noise_dirs = dir(snr_path);
        noise_dirs = noise_dirs([noise_dirs.isdir] & ~strcmp({noise_dirs.name}, '.') & ~strcmp({noise_dirs.name}, '..'));
        
        snr_total = 0;
        
        for noise_idx = 1:length(noise_dirs)
            noise_type = noise_dirs(noise_idx).name;
            noise_total = 0;
            
            for dataset_idx = 1:length(datasets)
                for group_idx = 1:length(groups)
                    group_path = fullfile(snr_path, noise_type, datasets{dataset_idx}, groups{group_idx});
                    
                    if exist(group_path, 'dir')
                        png_files = dir(fullfile(group_path, '*.png'));
                        count = length(png_files);
                        noise_total = noise_total + count;
                    end
                end
            end
            
            fprintf('  %s: %d scalograms\n', noise_type, noise_total);
            snr_total = snr_total + noise_total;
            
            % Store for summary
            field_name = sprintf('%s_%s', snr_name, noise_type);
            analysis_summary.(field_name) = noise_total;
        end
        
        fprintf('  Total for %s: %d scalograms\n', snr_name, snr_total);
        total_scalograms = total_scalograms + snr_total;
    end
    
    fprintf('\nGRAND TOTAL: %d noisy scalogram images\n', total_scalograms);
    
    % Calculate expansion factor
    original_estimate = total_scalograms / (length(snr_dirs) * 7); % 7 noise types
    fprintf('Original files (estimated): %d\n', round(original_estimate));
    fprintf('Expansion factor: %.1fx\n', total_scalograms / original_estimate);
    
    % Generate detailed analysis report
    generate_detailed_analysis_report(scalogram_output_path, analysis_summary, total_scalograms);
end

function generate_detailed_analysis_report(scalogram_output_path, analysis_summary, total_scalograms)
    % Generate detailed analysis report
    
    report_file = fullfile(scalogram_output_path, 'noisy_dataset_analysis_report.txt');
    fid = fopen(report_file, 'w');
    
    fprintf(fid, '=== NOISY SCALOGRAM DATASET DETAILED ANALYSIS ===\n');
    fprintf(fid, 'Generated: %s\n\n', datestr(now));
    
    fprintf(fid, 'DATASET OVERVIEW:\n');
    fprintf(fid, 'Total noisy scalogram images: %d\n', total_scalograms);
    fprintf(fid, 'Base directory: %s\n\n', scalogram_output_path);
    
    fprintf(fid, 'BREAKDOWN BY SNR AND NOISE TYPE:\n');
    
    field_names = fieldnames(analysis_summary);
    snr_levels = {};
    noise_types = {};
    
    % Extract unique SNR levels and noise types
    for i = 1:length(field_names)
        parts = strsplit(field_names{i}, '_');
        if length(parts) >= 3
            snr_part = strjoin(parts(1:2), '_'); % SNR_XXdB
            noise_part = strjoin(parts(3:end), '_'); % noise type
            
            if ~ismember(snr_part, snr_levels)
                snr_levels{end+1} = snr_part;
            end
            if ~ismember(noise_part, noise_types)
                noise_types{end+1} = noise_part;
            end
        end
    end
    
    % Sort SNR levels
    snr_levels = sort(snr_levels);
    
    fprintf(fid, 'SNR Levels: %d (%s)\n', length(snr_levels), strjoin(snr_levels, ', '));
    fprintf(fid, 'Noise Types: %d (%s)\n\n', length(noise_types), strjoin(noise_types, ', '));
    
    % Detailed breakdown
    for i = 1:length(snr_levels)
        fprintf(fid, '%s:\n', snr_levels{i});
        snr_total = 0;
        
        for j = 1:length(noise_types)
            field_name = sprintf('%s_%s', snr_levels{i}, noise_types{j});
            if isfield(analysis_summary, field_name)
                count = analysis_summary.(field_name);
                fprintf(fid, '  %s: %d\n', noise_types{j}, count);
                snr_total = snr_total + count;
            end
        end
        fprintf(fid, '  Subtotal: %d\n\n', snr_total);
    end
    
    fprintf(fid, 'RESEARCH RECOMMENDATIONS:\n');
    fprintf(fid, '1. Test model performance across all SNR levels\n');
    fprintf(fid, '2. Compare robustness to different noise types\n');
    fprintf(fid, '3. Identify critical SNR threshold for deployment\n');
    fprintf(fid, '4. Analyze performance degradation patterns\n');
    fprintf(fid, '5. Consider noise-specific training strategies\n\n');
    
    fprintf(fid, 'EXPECTED MODEL TESTING WORKFLOW:\n');
    fprintf(fid, '1. Train model on clean data\n');
    fprintf(fid, '2. Test on each SNR level separately\n');
    fprintf(fid, '3. Test on each noise type separately\n');
    fprintf(fid, '4. Generate performance curves vs SNR\n');
    fprintf(fid, '5. Identify optimal operating conditions\n');
    fprintf(fid, '6. Document robustness characteristics\n');
    
    fclose(fid);
    
    fprintf('Detailed analysis report saved to: %s\n', report_file);
end

% Main execution
fprintf('Starting Noisy ECG to Scalogram conversion...\n');
convert_noisy_ecg_to_scalograms();